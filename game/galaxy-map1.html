<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hyperjump Map Prototype</title>
  <style>
    /* Fullscreen canvas */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at center, #050509 0%, #020208 50%, #000000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #eee;
    }

    #ui-overlay {
      position: fixed;
      top: 10px;
      left: 10px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      backdrop-filter: blur(4px);
      font-size: 13px;
      z-index: 10;
    }

    #ui-overlay h1 {
      font-size: 14px;
      margin: 0 0 4px 0;
      font-weight: 600;
    }

    #ui-overlay p {
      margin: 2px 0;
    }

    #ui-overlay label {
      display: inline-block;
      margin-right: 8px;
    }

    #ui-overlay input[type="range"] {
      vertical-align: middle;
    }

    #renderer-container {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="ui-overlay">
    <h1>Hyperjump Map (Prototype)</h1>
    <p>Drag to rotate · Scroll to zoom · Right-drag to pan</p>
    <p>
      <label>Nodes: <span id="node-count-label">400</span></label>
      <input id="node-count" type="range" min="100" max="1500" value="400" />
      <button id="regen-btn">Regenerate</button>
    </p>
  </div>
  <div id="renderer-container"></div>

  <!-- Three.js from CDN (global THREE) -->
  <script src="https://unpkg.com/three@0.165.0/build/three.min.js"></script>
  <!-- OrbitControls (non-module version) -->
  <script src="https://unpkg.com/three@0.165.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Run with: npx http-server .   (or open this HTML file directly in your browser)

    // Basic constants (certainty ~95% that these ranges match your description)
    const X_MIN = -1000, X_MAX = 1000;
    const Y_MIN = -600,  Y_MAX = 600;
    const Z_MIN = -25,   Z_MAX = 25;

    let scene, camera, renderer, controls;
    let nodePoints = null;
    let edgeLines = null;

    const container = document.getElementById('renderer-container');
    const nodeCountSlider = document.getElementById('node-count');
    const nodeCountLabel = document.getElementById('node-count-label');
    const regenBtn = document.getElementById('regen-btn');

    init();
    generateGraph(parseInt(nodeCountSlider.value, 10));
    animate();

    function init() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      scene = new THREE.Scene();

      // Subtle space fog (certainty ~90% this gives a nice 2.5D feeling)
      scene.fog = new THREE.FogExp2(0x000008, 0.0008);

      camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);
      camera.position.set(0, 0, 2200);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(width, height);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x000000, 1);
      container.appendChild(renderer.domElement);

      // Subtle ambient light plus a "core" light
      const ambient = new THREE.AmbientLight(0x8888ff, 0.7);
      scene.add(ambient);

      const point = new THREE.PointLight(0x44ccff, 1.2, 4000);
      point.position.set(0, 0, 800);
      scene.add(point);

      // Orbit controls (drag rotate, scroll zoom)
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.rotateSpeed = 0.5;
      controls.zoomSpeed = 0.6;
      controls.panSpeed = 0.5;

      // Slight tilt for 2.5D "table-top" feel
      controls.minDistance = 600;
      controls.maxDistance = 3500;
      camera.position.y = 200;
      camera.lookAt(0, 0, 0);

      // Optional subtle background grid plane
      const grid = new THREE.GridHelper(2600, 26, 0x222244, 0x111122);
      grid.position.y = Y_MIN - 50; // slightly below the main cloud (certainty ~80%)
      scene.add(grid);

      window.addEventListener('resize', onWindowResize);
      nodeCountSlider.addEventListener('input', () => {
        nodeCountLabel.textContent = nodeCountSlider.value;
      });
      regenBtn.addEventListener('click', () => {
        const n = parseInt(nodeCountSlider.value, 10);
        generateGraph(n);
      });
    }

    function onWindowResize() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    }

    /**
     * Generate a free-form graph with:
     * - Nodes distributed in an ellipse in X/Y
     * - Center denser than periphery (using sqrt random radius) (certainty ~85%)
     * - Subtle spread in Z for 2.5D
     * - Edges linking each node to its K nearest neighbors
     */
    function generateGraph(nodeCount) {
      // Remove old geometry if any
      if (nodePoints) {
        scene.remove(nodePoints);
        nodePoints.geometry.dispose();
        nodePoints.material.dispose();
        nodePoints = null;
      }
      if (edgeLines) {
        scene.remove(edgeLines);
        edgeLines.geometry.dispose();
        edgeLines.material.dispose();
        edgeLines = null;
      }

      // Generate node positions
      const positions = [];
      const nodeData = [];

      const maxRadiusX = (X_MAX - X_MIN) / 2;
      const maxRadiusY = (Y_MAX - Y_MIN) / 2;
      const centerX = (X_MAX + X_MIN) / 2;
      const centerY = (Y_MAX + Y_MIN) / 2;
      const maxZ = (Z_MAX - Z_MIN) / 2;

      for (let i = 0; i < nodeCount; i++) {
        // Random angle in XY plane
        const theta = Math.random() * Math.PI * 2;

        // Radius biased toward center: r = R * sqrt(u)
        const u = Math.random();
        const rX = maxRadiusX * Math.sqrt(u);
        const rY = maxRadiusY * Math.sqrt(u);

        const x = centerX + Math.cos(theta) * rX;
        const y = centerY + Math.sin(theta) * rY;

        // Subtle Z: more likely near 0, but still in [-maxZ, maxZ]
        const v = (Math.random() + Math.random()) / 2; // triangle distribution
        const z = (v - 0.5) * 2 * maxZ;

        positions.push(x, y, z);
        nodeData.push({ x, y, z });
      }

      // Create node points
      const nodeGeometry = new THREE.BufferGeometry();
      nodeGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(positions, 3)
      );

      // Colors: nearer to center brighter/cyan, periphery darker
      const colors = [];
      for (let i = 0; i < nodeCount; i++) {
        const { x, y, z } = nodeData[i];
        const dx = x - centerX;
        const dy = y - centerY;
        const distNorm = Math.min(
          Math.sqrt(
            (dx * dx) / (maxRadiusX * maxRadiusX) +
            (dy * dy) / (maxRadiusY * maxRadiusY)
          ),
          1
        );
        const depthFactor = 0.5 + 0.5 * (1 - Math.abs(z) / maxZ);
        const intensity = (1 - distNorm * 0.8) * depthFactor;

        const r = 0.2 * intensity;
        const g = 0.7 * intensity + 0.1;
        const b = 1.0 * intensity;

        colors.push(r, g, b);
      }
      nodeGeometry.setAttribute(
        'color',
        new THREE.Float32BufferAttribute(colors, 3)
      );

      const nodeMaterial = new THREE.PointsMaterial({
        size: 10,
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 0.98,
      });

      nodePoints = new THREE.Points(nodeGeometry, nodeMaterial);
      scene.add(nodePoints);

      // Build edges: connect each node to its K nearest neighbors
      const K = 3; // small for readability; tweak later (certainty ~90% this is a good default)
      const edgePositions = [];

      for (let i = 0; i < nodeCount; i++) {
        const base = nodeData[i];
        // compute distances
        const distances = [];
        for (let j = 0; j < nodeCount; j++) {
          if (i === j) continue;
          const other = nodeData[j];
          const dx = base.x - other.x;
          const dy = base.y - other.y;
          const dz = base.z - other.z;
          const d2 = dx * dx + dy * dy + dz * dz;
          distances.push({ j, d2 });
        }
        distances.sort((a, b) => a.d2 - b.d2);
        const neighbours = distances.slice(0, K);

        neighbours.forEach(({ j }) => {
          const n = nodeData[j];
          edgePositions.push(base.x, base.y, base.z);
          edgePositions.push(n.x, n.y, n.z);
        });
      }

      const edgeGeometry = new THREE.BufferGeometry();
      edgeGeometry.setAttribute(
        'position',
        new THREE.Float32BufferAttribute(edgePositions, 3)
      );

      const edgeMaterial = new THREE.LineBasicMaterial({
        color: 0x3388ff,
        opacity: 0.28,
        transparent: true,
      });

      edgeLines = new THREE.LineSegments(edgeGeometry, edgeMaterial);
      scene.add(edgeLines);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();

      // Very slow auto-rotation for a "living map" feel
      if (nodePoints) {
        nodePoints.rotation.z += 0.0001;
      }
      if (edgeLines) {
        edgeLines.rotation.z += 0.0001;
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
