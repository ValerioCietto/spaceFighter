<!-- Terminal: python -m http.server 8080 -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Human Station — Big Animated Habitat</title>
  <style>
    html,body{margin:0;height:100%;background:#050712;color:#e7efff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{
      position:fixed;left:0;right:0;top:0;z-index:2;
      padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.12);
      background:rgba(10,16,40,.72);backdrop-filter: blur(8px);
    }
    .sub{font-size:12px;color:rgba(231,239,255,.7)}
    canvas{display:block;width:100vw;height:100vh}
  </style>
</head>
<body>
<header>
  <div><b>Human Rotating Habitat Station</b></div>
  <div class="sub">Rotating ring • Hexagonal shield • Forest bubble • Slowly blinking lights</div>
</header>
<canvas id="c"></canvas>

<script>
  // Terminal: python -m http.server 8080
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resize(){
    c.width = Math.floor(innerWidth * DPR);
    c.height = Math.floor(innerHeight * DPR);
  }
  addEventListener("resize", resize);
  resize();

  // --- helpers
  function clamp(a,b,c){ return Math.max(b, Math.min(c,a)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  function seededRand(seed){
    let t = seed >>> 0;
    return () => (t = (t * 1664525 + 1013904223) >>> 0) / 4294967296;
  }

  function drawStars(time){
    ctx.save();
    ctx.fillStyle = "#050712";
    ctx.fillRect(0,0,c.width,c.height);

    // subtle nebula
    const g1 = ctx.createRadialGradient(c.width*0.25,c.height*0.35,0, c.width*0.25,c.height*0.35, c.width*0.55);
    g1.addColorStop(0,"rgba(80,120,255,0.08)");
    g1.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = g1;
    ctx.fillRect(0,0,c.width,c.height);

    const g2 = ctx.createRadialGradient(c.width*0.75,c.height*0.55,0, c.width*0.75,c.height*0.55, c.width*0.6);
    g2.addColorStop(0,"rgba(255,120,200,0.06)");
    g2.addColorStop(1,"rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.fillRect(0,0,c.width,c.height);

    // stars
    const R = seededRand(1337);
    for(let i=0;i<900;i++){
      const x = R()*c.width;
      const y = R()*c.height;
      const tw = 0.35 + 0.65*Math.sin(time*0.0004 + i*0.7);
      const a = (R()<0.93 ? 0.55 : 0.9) * (0.45 + 0.55*tw);
      const s = (R()<0.92 ? 1 : 2) * DPR;
      ctx.fillStyle = `rgba(231,239,255,${a})`;
      ctx.fillRect(x,y,s,s);
    }
    ctx.restore();
  }

  function poly(ctx, points){
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1;i<points.length;i++) ctx.lineTo(points[i].x, points[i].y);
    ctx.closePath();
  }

  function hexPoints(cx,cy,r,rot){
    const pts=[];
    for(let i=0;i<6;i++){
      const a = rot + i*Math.PI/3;
      pts.push({x:cx + Math.cos(a)*r, y:cy + Math.sin(a)*r});
    }
    return pts;
  }

  function glowCircle(x,y,r,rgba){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(x,y,0, x,y,r);
    g.addColorStop(0, rgba);
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }

  // --- station assets (procedural)
  const lights = [];
  const panels = [];
  const R0 = seededRand(2025);

  function initStationGeometry(){
    lights.length = 0;
    panels.length = 0;

    // ring lights
    for(let i=0;i<160;i++){
      const a = (i/160)*Math.PI*2;
      lights.push({
        kind:"ring",
        a,
        rMul: 1.0 + (R0()*0.06-0.03),
        phase: R0()*Math.PI*2,
        speed: 0.25 + R0()*0.35,
        size: 1 + (R0()*2|0)
      });
    }

    // hex shield nodes
    for(let i=0;i<30;i++){
      lights.push({
        kind:"shield",
        a: R0()*Math.PI*2,
        rMul: 1.0,
        phase: R0()*Math.PI*2,
        speed: 0.12 + R0()*0.18,
        size: 1 + (R0()*2|0)
      });
    }

    // random hull panels on core
    for(let i=0;i<140;i++){
      panels.push({
        a: R0()*Math.PI*2,
        y: (R0()*2-1),
        w: 0.02 + R0()*0.05,
        h: 0.01 + R0()*0.04,
        alpha: 0.05 + R0()*0.08
      });
    }
  }
  initStationGeometry();

  // --- draw parts
  function drawCore(x,y,coreR,time){
    ctx.save();
    // core gradient
    const g = ctx.createRadialGradient(x-coreR*0.2,y-coreR*0.2,coreR*0.1, x,y,coreR*1.2);
    g.addColorStop(0,"rgba(255,255,255,0.35)");
    g.addColorStop(0.30,"rgba(200,215,255,0.16)");
    g.addColorStop(0.75,"rgba(40,55,110,0.55)");
    g.addColorStop(1,"rgba(0,0,0,0.55)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,coreR,0,Math.PI*2); ctx.fill();

    // paneling (lat-long feel)
    ctx.strokeStyle = "rgba(220,230,255,0.18)";
    ctx.lineWidth = coreR*0.012;
    for(let i=0;i<10;i++){
      const rr = lerp(coreR*0.15, coreR*0.95, i/9);
      ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.stroke();
    }
    for(let i=0;i<12;i++){
      const a = (i/12)*Math.PI*2 + time*0.00005;
      ctx.beginPath();
      ctx.moveTo(x + Math.cos(a)*coreR*0.05, y + Math.sin(a)*coreR*0.05);
      ctx.lineTo(x + Math.cos(a)*coreR*0.98, y + Math.sin(a)*coreR*0.98);
      ctx.stroke();
    }

    // small rectangular panels
    ctx.save();
    ctx.translate(x,y);
    for(const p of panels){
      const a = p.a + time*0.00003;
      const rr = coreR*(0.55 + 0.35*Math.cos(p.y*1.3));
      const px = Math.cos(a)*rr;
      const py = Math.sin(a)*rr*0.72;
      ctx.save();
      ctx.translate(px,py);
      ctx.rotate(a);
      ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
      ctx.fillRect(-coreR*p.w, -coreR*p.h, coreR*p.w*2, coreR*p.h*2);
      ctx.restore();
    }
    ctx.restore();

    // “reactor spine”
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = "rgba(140,220,255,0.18)";
    ctx.lineWidth = coreR*0.04;
    ctx.beginPath();
    ctx.arc(x,y,coreR*0.55, -0.3, 1.8);
    ctx.stroke();
    glowCircle(x+coreR*0.15, y-coreR*0.1, coreR*0.35, "rgba(140,220,255,0.18)");
    ctx.restore();

    ctx.restore();
  }

  function drawRotatingHabitat(x,y,ringR,time){
    const rot = time*0.00035; // rotation speed
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);

    // ring body
    ctx.strokeStyle = "rgba(230,240,255,0.55)";
    ctx.lineWidth = ringR*0.18;
    ctx.beginPath();
    ctx.ellipse(0,0, ringR*0.98, ringR*0.60, 0, 0, Math.PI*2);
    ctx.stroke();

    // inner ring shadow for depth
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = ringR*0.10;
    ctx.beginPath();
    ctx.ellipse(0,0, ringR*0.82, ringR*0.46, 0, 0, Math.PI*2);
    ctx.stroke();

    // spokes
    ctx.strokeStyle = "rgba(210,220,255,0.25)";
    ctx.lineWidth = ringR*0.05;
    for(let i=0;i<8;i++){
      const a = (i/8)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*ringR*0.18, Math.sin(a)*ringR*0.10);
      ctx.lineTo(Math.cos(a)*ringR*0.82, Math.sin(a)*ringR*0.46);
      ctx.stroke();
    }

    // window bands
    ctx.strokeStyle = "rgba(140,220,255,0.12)";
    ctx.lineWidth = ringR*0.035;
    for(let i=0;i<4;i++){
      const rrX = ringR*(0.92 - i*0.08);
      const rrY = ringR*(0.56 - i*0.05);
      ctx.beginPath();
      ctx.ellipse(0,0, rrX, rrY, 0, 0, Math.PI*2);
      ctx.stroke();
    }

    // blinking lights around ring (slow)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for(const L of lights){
      if(L.kind!=="ring") continue;
      const a = L.a;
      const px = Math.cos(a)*ringR*0.98;
      const py = Math.sin(a)*ringR*0.60;
      const blink = 0.25 + 0.75*(0.5+0.5*Math.sin(time*0.00025*L.speed + L.phase));
      const alpha = 0.08 + 0.22*blink;
      ctx.fillStyle = `rgba(140,220,255,${alpha})`;
      ctx.beginPath();
      ctx.arc(px,py, (L.size*DPR)*1.2, 0, Math.PI*2);
      ctx.fill();
      if(blink>0.75) glowCircle(x+px, y+py, ringR*0.06, `rgba(140,220,255,${0.08+0.10*blink})`);
    }
    ctx.restore();

    ctx.restore();
  }

  function drawHexShield(x,y,shieldR,time){
    const rot = -time*0.00012;
    const pts = hexPoints(x,y,shieldR,rot);

    // outer hex (field)
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    poly(ctx, pts);
    ctx.fillStyle = "rgba(120,170,255,0.05)";
    ctx.fill();

    ctx.strokeStyle = "rgba(140,220,255,0.22)";
    ctx.lineWidth = shieldR*0.018;
    ctx.stroke();

    // inner hex lines
    const pts2 = hexPoints(x,y,shieldR*0.86,rot+0.08);
    poly(ctx, pts2);
    ctx.strokeStyle = "rgba(255,140,220,0.10)";
    ctx.lineWidth = shieldR*0.010;
    ctx.stroke();

    // shield nodes that blink
    for(const L of lights){
      if(L.kind!=="shield") continue;
      const a = L.a + rot*0.6;
      const px = x + Math.cos(a)*shieldR*0.98;
      const py = y + Math.sin(a)*shieldR*0.60;
      const blink = 0.35 + 0.65*(0.5+0.5*Math.sin(time*0.00018*L.speed + L.phase));
      glowCircle(px,py, shieldR*0.08, `rgba(140,220,255,${0.06+0.10*blink})`);
    }

    ctx.restore();
  }

  function drawForestBubble(x,y,bubR,time){
    // bubble shell
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    const g = ctx.createRadialGradient(x-bubR*0.2,y-bubR*0.25,0, x,y,bubR*1.1);
    g.addColorStop(0,"rgba(160,255,220,0.18)");
    g.addColorStop(0.55,"rgba(160,255,220,0.06)");
    g.addColorStop(1,"rgba(160,255,220,0.00)");
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,bubR,0,Math.PI*2); ctx.fill();

    // rim
    ctx.strokeStyle = "rgba(160,255,220,0.22)";
    ctx.lineWidth = bubR*0.06;
    ctx.beginPath(); ctx.arc(x,y,bubR*0.98,0,Math.PI*2); ctx.stroke();

    // inside: forest canopy blobs + water
    ctx.save();
    ctx.beginPath(); ctx.arc(x,y,bubR*0.92,0,Math.PI*2); ctx.clip();

    // atmosphere haze
    const haze = ctx.createRadialGradient(x,y,bubR*0.2, x,y,bubR);
    haze.addColorStop(0,"rgba(255,255,255,0.08)");
    haze.addColorStop(1,"rgba(0,0,0,0.12)");
    ctx.fillStyle = haze;
    ctx.fillRect(x-bubR,y-bubR,bubR*2,bubR*2);

    const sway = Math.sin(time*0.00035)*0.04;
    ctx.fillStyle = "rgba(60,200,120,0.20)";
    for(let i=0;i<18;i++){
      const a = (i/18)*Math.PI*2;
      const rr = bubR*(0.22 + (i%5)*0.07);
      const px = x + Math.cos(a+sway)*rr;
      const py = y + Math.sin(a-sway)*rr*0.75;
      ctx.beginPath();
      ctx.ellipse(px,py,bubR*(0.18),bubR*(0.10), a, 0, Math.PI*2);
      ctx.fill();
    }

    // lake
    ctx.fillStyle = "rgba(120,220,255,0.14)";
    ctx.beginPath();
    ctx.ellipse(x+bubR*0.12,y+bubR*0.18,bubR*0.36,bubR*0.18,-0.2,0,Math.PI*2);
    ctx.fill();

    // tiny internal “sunlight” flicker
    const flick = 0.08 + 0.06*(0.5+0.5*Math.sin(time*0.00022));
    glowCircle(x-bubR*0.15, y-bubR*0.2, bubR*0.55, `rgba(255,255,255,${flick})`);

    ctx.restore();
    ctx.restore();
  }

  function drawDockingArms(x,y,coreR,time){
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(time*0.00005);
    ctx.strokeStyle="rgba(220,230,255,0.30)";
    ctx.lineWidth=coreR*0.07;
    for(let i=0;i<3;i++){
      const a = (i/3)*Math.PI*2 + 0.5;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*coreR*0.75, Math.sin(a)*coreR*0.45);
      ctx.lineTo(Math.cos(a)*coreR*1.25, Math.sin(a)*coreR*0.75);
      ctx.stroke();

      // clamp heads
      ctx.fillStyle="rgba(200,215,255,0.18)";
      ctx.beginPath();
      ctx.ellipse(Math.cos(a)*coreR*1.28, Math.sin(a)*coreR*0.78, coreR*0.18, coreR*0.10, a, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawStation(time){
    const x = c.width*0.56;
    const y = c.height*0.56;
    const base = Math.min(c.width,c.height) * 0.24;

    const coreR = base*0.65;
    const ringR = base*1.35;
    const shieldR = base*1.65;

    // parallax drift
    const driftX = Math.sin(time*0.00012)*base*0.06;
    const driftY = Math.cos(time*0.00010)*base*0.05;

    const X = x + driftX;
    const Y = y + driftY;

    // background glow behind station
    glowCircle(X, Y, base*2.2, "rgba(120,170,255,0.05)");
    glowCircle(X, Y, base*1.4, "rgba(255,140,220,0.03)");

    // shield behind everything
    drawHexShield(X,Y,shieldR,time);

    // docking arms + core
    drawDockingArms(X,Y,coreR,time);
    drawCore(X,Y,coreR,time);

    // rotating ring habitat
    drawRotatingHabitat(X,Y,ringR,time);

    // forest bubble attached to ring (top-right)
    const bubbleA = time*0.00035 + 0.9;
    const bx = X + Math.cos(bubbleA)*ringR*0.82;
    const by = Y + Math.sin(bubbleA)*ringR*0.50;
    drawForestBubble(bx,by, base*0.40, time);

    // small blinking nav lights on core edges
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    for(let i=0;i<18;i++){
      const a = (i/18)*Math.PI*2 + time*0.00008;
      const px = X + Math.cos(a)*coreR*0.98;
      const py = Y + Math.sin(a)*coreR*0.72;
      const blink = 0.25 + 0.75*(0.5+0.5*Math.sin(time*0.00020 + i*0.9));
      ctx.fillStyle = `rgba(255,220,140,${0.05+0.18*blink})`;
      ctx.beginPath(); ctx.arc(px,py, 1.2*DPR, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  function frame(time){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(1,1);

    drawStars(time);

    // subtle vignette
    const vg = ctx.createRadialGradient(c.width*0.5,c.height*0.6,0, c.width*0.5,c.height*0.6, Math.max(c.width,c.height)*0.7);
    vg.addColorStop(0,"rgba(0,0,0,0)");
    vg.addColorStop(1,"rgba(0,0,0,0.45)");
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,c.width,c.height);

    // station
    drawStation(time);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
</script>
</body>
</html>