<!-- Terminal: python3 -m http.server 8080 -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Engine Flare Demo</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;color:#e8eefc;font-family:system-ui,Segoe UI,Roboto,Arial}
    #wrap{display:grid;grid-template-columns:320px 1fr;gap:12px;height:100%;padding:12px;box-sizing:border-box}
    #panel{background:#0b1020;border:1px solid #1c2a52;border-radius:12px;padding:12px}
    #panel h1{font-size:16px;margin:0 0 10px 0;font-weight:650}
    .row{display:grid;grid-template-columns:110px 1fr;gap:10px;align-items:center;margin:10px 0}
    label{font-size:12px;color:#b9c7ef}
    input[type="range"]{width:100%}
    select,input[type="color"]{width:100%;padding:6px;border-radius:10px;border:1px solid #20315f;background:#0a1330;color:#e8eefc}
    #hint{font-size:12px;color:#aab7dd;line-height:1.35;margin-top:10px}
    canvas{width:100%;height:100%;background:radial-gradient(1200px 700px at 65% 40%, #0a0f22 0%, #05060a 55%, #03040a 100%);
      border-radius:12px;border:1px solid #121a36}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#101a3a;border:1px solid #23366c;color:#bcd0ff;font-size:11px}
  </style>
</head>
<body>
  <div id="wrap">
    <div id="panel">
      <h1>Space Engine Flare</h1>

      <div class="row">
        <label>Shape</label>
        <select id="shape">
          <option value="triangular">Triangular</option>
          <option value="sphere">Sphere</option>
          <option value="flagellum">Flagellum</option>
          <option value="fire">Fire</option>
        </select>
      </div>

      <div class="row">
        <label>Color</label>
        <input id="color" type="color" value="#7fd4ff" />
      </div>

      <div class="row">
        <label>Length</label>
        <input id="length" type="range" min="20" max="420" value="220" />
      </div>

      <div class="row">
        <label>Width</label>
        <input id="width" type="range" min="6" max="120" value="46" />
      </div>

      <div class="row">
        <label>Intensity</label>
        <input id="intensity" type="range" min="0" max="100" value="70" />
      </div>

      <div class="row">
        <label>Flicker</label>
        <input id="flicker" type="range" min="0" max="100" value="40" />
      </div>

      <div class="row">
        <label>Particles</label>
        <input id="particles" type="range" min="0" max="250" value="120" />
      </div>

      <div class="row">
        <label>Auto thrust</label>
        <input id="auto" type="checkbox" checked />
      </div>

      <div id="hint">
        Drag on canvas to move the ship. <span class="pill">Space</span> toggles pause.
      </div>

      <div style="margin-top:10px;font-size:12px;color:#9fb0df">
        Certainty: 92%
      </div>
    </div>

    <canvas id="c"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    shape: document.getElementById('shape'),
    color: document.getElementById('color'),
    length: document.getElementById('length'),
    width: document.getElementById('width'),
    intensity: document.getElementById('intensity'),
    flicker: document.getElementById('flicker'),
    particles: document.getElementById('particles'),
    auto: document.getElementById('auto'),
  };

  const state = {
    t: 0,
    paused: false,
    ship: { x: 0, y: 0, angle: 0 },
    drag: { on: false, ox: 0, oy: 0 },
    particles: [],
  };

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Init ship center-left
  function initShip() {
    state.ship.x = canvas.clientWidth * 0.35;
    state.ship.y = canvas.clientHeight * 0.55;
    state.ship.angle = 0;
  }
  initShip();

  // Simple input: drag ship
  function getPos(e) {
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return { x, y };
  }
  function down(e) {
    const p = getPos(e);
    state.drag.on = true;
    state.drag.ox = p.x - state.ship.x;
    state.drag.oy = p.y - state.ship.y;
    e.preventDefault?.();
  }
  function move(e) {
    if (!state.drag.on) return;
    const p = getPos(e);
    state.ship.x = p.x - state.drag.ox;
    state.ship.y = p.y - state.drag.oy;
    e.preventDefault?.();
  }
  function up() { state.drag.on = false; }

  canvas.addEventListener('mousedown', down);
  window.addEventListener('mousemove', move);
  window.addEventListener('mouseup', up);
  canvas.addEventListener('touchstart', down, { passive: false });
  window.addEventListener('touchmove', move, { passive: false });
  window.addEventListener('touchend', up);

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') state.paused = !state.paused;
  });

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

  function hexToRgb(hex) {
    const h = hex.replace('#','').trim();
    const n = parseInt(h.length === 3 ? h.split('').map(c=>c+c).join('') : h, 16);
    return { r: (n>>16)&255, g: (n>>8)&255, b: n&255 };
  }
  function rgba({r,g,b}, a) { return `rgba(${r},${g},${b},${a})`; }
  function mix(a, b, t) { return a + (b-a)*t; }

  function drawStarfield() {
    // tiny deterministic stars
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.save();
    ctx.globalAlpha = 0.8;
    for (let i=0;i<140;i++){
      const x = (i*9973 % 1000)/1000*w;
      const y = (i*6113 % 1000)/1000*h;
      const s = ((i*37)%1000)/1000;
      ctx.globalAlpha = 0.18 + s*0.5;
      ctx.fillStyle = '#dbe6ff';
      ctx.fillRect(x, y, s<0.6?1:2, s<0.6?1:2);
    }
    ctx.restore();
  }

  function drawShip() {
    const {x,y,angle} = state.ship;
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);

    // hull
    ctx.fillStyle = '#c8d2ea';
    ctx.strokeStyle = '#6b7fb0';
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.moveTo(30, 0);
    ctx.quadraticCurveTo(5, -18, -22, -10);
    ctx.lineTo(-28, -6);
    ctx.lineTo(-32, 0);
    ctx.lineTo(-28, 6);
    ctx.lineTo(-22, 10);
    ctx.quadraticCurveTo(5, 18, 30, 0);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // cockpit
    ctx.fillStyle = 'rgba(120,200,255,0.25)';
    ctx.strokeStyle = 'rgba(140,220,255,0.55)';
    ctx.beginPath();
    ctx.ellipse(10, -3, 10, 7, 0.1, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // engine nozzle
    ctx.fillStyle = '#6b7fb0';
    ctx.beginPath();
    ctx.roundRect(-42, -8, 14, 16, 5);
    ctx.fill();

    ctx.restore();
  }

  // particle system for trailing glow
  function spawnParticles(originX, originY, dirX, dirY, rate, baseColor, thrust, width) {
    const count = Math.floor(rate);
    for (let i=0;i<count;i++){
      const spread = (Math.random()*2-1) * (0.25 + width/140);
      const speed = (1.2 + Math.random()*2.2) * (0.6 + thrust*1.8);
      const life = 16 + Math.random()*24;
      const off = (Math.random()*2-1) * (width*0.35);
      // perpendicular vector
      const px = -dirY, py = dirX;
      state.particles.push({
        x: originX + px*off,
        y: originY + py*off,
        vx: dirX * -speed + px*spread*2.0,
        vy: dirY * -speed + py*spread*2.0,
        life,
        max: life,
        r: baseColor.r, g: baseColor.g, b: baseColor.b
      });
    }
  }

  function updateParticles(dt) {
    const drag = 0.985;
    for (const p of state.particles) {
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= drag;
      p.vy *= drag;
      p.life -= dt;
    }
    state.particles = state.particles.filter(p => p.life > 0);
  }

  function drawParticles() {
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (const p of state.particles) {
      const a = clamp(p.life / p.max, 0, 1);
      const radius = 1.5 + (1-a)*6.5;
      const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius);
      grad.addColorStop(0, rgba(p, 0.55*a));
      grad.addColorStop(1, rgba(p, 0));
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(p.x, p.y, radius, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawFlare(params) {
    const { x, y, angle } = state.ship;

    const base = hexToRgb(params.color);
    const len = params.length;
    const width = params.width;
    const intensity = params.intensity;
    const flicker = params.flicker;

    // thrust factor
    const auto = ui.auto.checked;
    const thrust = auto
      ? (0.55 + 0.45*Math.sin(state.t*0.9) * 0.5 + 0.45*Math.sin(state.t*0.23 + 1.1) * 0.5)
      : 1.0;

    const flick = 1.0 + (Math.random()*2-1) * (flicker/100) * 0.25;
    const L = len * mix(0.75, 1.2, thrust) * flick;
    const W = width * mix(0.75, 1.1, thrust);

    // engine exit point in ship space
    const ex = x + Math.cos(angle) * (-42);
    const ey = y + Math.sin(angle) * (-42);

    // direction unit vector (ship forward is +x; exhaust goes -x)
    const dx = Math.cos(angle), dy = Math.sin(angle);
    const ox = -dx, oy = -dy;

    // spawn particles
    const pRate = (params.particles/250) * (2 + 10*thrust) * (intensity/100);
    spawnParticles(ex + ox*6, ey + oy*6, dx, dy, pRate, base, thrust, W);

    ctx.save();
    ctx.globalCompositeOperation = 'lighter';

    // common: a soft core gradient "tube"
    const gx = ex + ox*(L*0.55);
    const gy = ey + oy*(L*0.55);
    const grad = ctx.createRadialGradient(gx, gy, 1, gx, gy, Math.max(12, W*1.1));
    grad.addColorStop(0.0, rgba(base, 0.10*intensity/100));
    grad.addColorStop(0.25, rgba(base, 0.22*intensity/100));
    grad.addColorStop(1.0, rgba(base, 0));
    ctx.fillStyle = grad;

    // draw an oriented "capsule"
    ctx.translate(ex, ey);
    ctx.rotate(angle + Math.PI); // exhaust points to +x in this local frame
    ctx.beginPath();
    ctx.roundRect(0, -W*0.35, L*0.95, W*0.7, W*0.35);
    ctx.fill();

    // shape-specific overlay
    const a0 = 0.85 * (intensity/100);
    ctx.strokeStyle = rgba(base, 0.65 * (intensity/100));
    ctx.lineWidth = 1.5;

    if (params.shape === 'triangular') {
      const tip = L;
      ctx.fillStyle = rgba(base, 0.18 + 0.22*a0);
      ctx.beginPath();
      ctx.moveTo(0, -W*0.22);
      ctx.lineTo(tip, 0);
      ctx.lineTo(0, W*0.22);
      ctx.closePath();
      ctx.fill();

      // inner bright spine
      ctx.strokeStyle = rgba(base, 0.35 + 0.35*a0);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(L*0.85, 0);
      ctx.stroke();
    }

    if (params.shape === 'sphere') {
      // stack of glowing beads
      const beads = Math.floor(6 + L/55);
      for (let i=0;i<beads;i++){
        const t = i/(beads-1);
        const bx = mix(8, L*0.95, t);
        const r = mix(W*0.22, W*0.05, t) * (0.7 + 0.45*Math.random());
        const g2 = ctx.createRadialGradient(bx, 0, 0, bx, 0, r*3.4);
        g2.addColorStop(0, rgba(base, (0.20 + 0.35*a0)*(1-t)));
        g2.addColorStop(0.25, rgba(base, (0.10 + 0.25*a0)*(1-t)));
        g2.addColorStop(1, rgba(base, 0));
        ctx.fillStyle = g2;
        ctx.beginPath();
        ctx.arc(bx, 0, r*3.4, 0, Math.PI*2);
        ctx.fill();
      }
    }

    if (params.shape === 'flagellum') {
      // wavy filament tail
      const segs = Math.floor(18 + L/12);
      ctx.lineCap = 'round';
      for (let k=0;k<2;k++){
        const phase = state.t*(1.3 + k*0.4) + k*1.7;
        ctx.beginPath();
        for (let i=0;i<=segs;i++){
          const t = i/segs;
          const px = t*L;
          const amp = (1-t) * (W*0.25) * (0.6 + 0.4*Math.sin(state.t*0.7));
          const py = Math.sin(phase + t*10) * amp;
          if (i===0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.strokeStyle = rgba(base, (0.30 + 0.30*a0) * (k?0.6:1.0));
        ctx.lineWidth = mix(W*0.10, W*0.02, 0.7) * (k?0.6:1.0);
        ctx.stroke();
      }
    }

    if (params.shape === 'fire') {
      // layered flame lobes
      const lobes = 4;
      for (let i=0;i<lobes;i++){
        const t = i/(lobes-1);
        const l = L * mix(0.55, 1.0, 1-t) * (0.8 + Math.random()*0.35);
        const w = W * mix(0.60, 1.15, 1-t) * (0.8 + Math.random()*0.35);
        const jitter = (Math.random()*2-1) * W*0.08;
        ctx.fillStyle = rgba(base, (0.08 + 0.18*a0) * (1-t));
        ctx.beginPath();
        ctx.moveTo(0, -w*0.18 + jitter);
        ctx.quadraticCurveTo(l*0.35, -w*0.55 + jitter, l*0.85, 0);
        ctx.quadraticCurveTo(l*0.35, w*0.55 + jitter, 0, w*0.18 + jitter);
        ctx.closePath();
        ctx.fill();
      }

      // hot core line
      ctx.strokeStyle = rgba(base, 0.45 + 0.35*a0);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(L*0.6, 0);
      ctx.stroke();
    }

    // nozzle bloom
    const bloom = ctx.createRadialGradient(0, 0, 0, 0, 0, W*0.9);
    bloom.addColorStop(0, rgba(base, 0.22 + 0.28*a0));
    bloom.addColorStop(1, rgba(base, 0));
    ctx.fillStyle = bloom;
    ctx.beginPath();
    ctx.arc(0, 0, W*0.9, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function tick(now) {
    requestAnimationFrame(tick);
    if (state.paused) return;

    const w = canvas.clientWidth, h = canvas.clientHeight;
    state.t = now * 0.001;

    // clear
    ctx.clearRect(0, 0, w, h);

    drawStarfield();

    // slight ship bob
    const bob = Math.sin(state.t*0.9) * 1.5;
    state.ship.y += bob * 0.02;

    // flare under ship (draw first so ship appears on top)
    drawFlare({
      shape: ui.shape.value,
      color: ui.color.value,
      length: +ui.length.value,
      width: +ui.width.value,
      intensity: (+ui.intensity.value)/100,
      flicker: +ui.flicker.value,
      particles: +ui.particles.value,
    });

    updateParticles(1.0);
    drawParticles();

    drawShip();
  }

  requestAnimationFrame(tick);
})();
</script>
</body>
</html>