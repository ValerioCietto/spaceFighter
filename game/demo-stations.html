<!-- Terminal: python -m http.server 8080 -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas Stations â€” 10 Types</title>
  <style>
    body{margin:0;background:#050712;color:#e7efff;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.12);background:rgba(10,16,40,.75)}
    .sub{font-size:12px;color:rgba(231,239,255,.7)}
    canvas{display:block;margin:0 auto}
  </style>
</head>
<body>
<header>
  <div><b>10 Canvas-Drawn Space Stations</b></div>
  <div class="sub">Types: ring-habitat, octagonal hub, refinery, shipyard, antenna array, fortress, garden dome, scrapyard, relay beacon, research lab</div>
</header>
<canvas id="c" width="1100" height="760"></canvas>

<script>
  // Terminal: python -m http.server 8080
  const c = document.getElementById("c");
  const ctx = c.getContext("2d");

  function rand(seed){
    let t = seed >>> 0;
    return () => (t = (t * 1664525 + 1013904223) >>> 0) / 4294967296;
  }

  function addStars(){
    ctx.fillStyle = "#050712";
    ctx.fillRect(0,0,c.width,c.height);
    for(let i=0;i<520;i++){
      const x = Math.random()*c.width;
      const y = Math.random()*c.height;
      const a = Math.random()*0.8;
      const s = Math.random()<0.92 ? 1 : 2;
      ctx.fillStyle = `rgba(231,239,255,${a})`;
      ctx.fillRect(x,y,s,s);
    }
  }

  function label(x,y,t){
    ctx.fillStyle = "rgba(231,239,255,0.92)";
    ctx.font = "12px system-ui,Segoe UI,Roboto,Arial";
    ctx.fillText(t, x-88, y+90);
  }

  function shadow(x,y,r){
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(x + r*0.22, y + r*0.28, r*0.9, r*0.45, 0, 0, Math.PI*2);
    ctx.fill();
  }

  function metalFill(x,y,r,seed){
    const R = rand(seed);
    const g = ctx.createRadialGradient(x-r*0.2,y-r*0.2,r*0.2, x,y,r*1.2);
    g.addColorStop(0,"rgba(255,255,255,0.45)");
    g.addColorStop(0.25,"rgba(210,220,255,0.18)");
    g.addColorStop(0.65,"rgba(40,55,110,0.55)");
    g.addColorStop(1,"rgba(0,0,0,0.55)");
    ctx.fillStyle = g;
    ctx.fillRect(x-r*1.6,y-r*1.6,r*3.2,r*3.2);

    // tiny panel noise
    for(let i=0;i<160;i++){
      const px = x + (R()*2-1)*r*1.4;
      const py = y + (R()*2-1)*r*1.1;
      const w = 4 + (R()*10|0);
      const h = 2 + (R()*6|0);
      ctx.fillStyle = `rgba(255,255,255,${0.03+R()*0.05})`;
      ctx.fillRect(px,py,w,h);
    }
  }

  function boltLights(points, a=0.6){
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for(const p of points){
      const g = ctx.createRadialGradient(p.x,p.y,0, p.x,p.y,p.r);
      g.addColorStop(0, `rgba(140,220,255,${a})`);
      g.addColorStop(1, "rgba(140,220,255,0)");
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();
  }

  // 1) Ring Habitat
  function ringHabitat(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // ring
    ctx.strokeStyle = "rgba(220,230,255,0.55)";
    ctx.lineWidth = r*0.18;
    ctx.beginPath();
    ctx.ellipse(x,y,r*0.95,r*0.55, -0.15, 0, Math.PI*2);
    ctx.stroke();
    // inner ring shadow
    ctx.strokeStyle = "rgba(0,0,0,0.22)";
    ctx.lineWidth = r*0.10;
    ctx.beginPath();
    ctx.ellipse(x,y,r*0.80,r*0.42, -0.15, 0, Math.PI*2);
    ctx.stroke();
    // hub
    ctx.fillStyle = "rgba(200,215,255,0.55)";
    ctx.beginPath(); ctx.arc(x,y,r*0.20,0,Math.PI*2); ctx.fill();
    // spokes
    ctx.strokeStyle = "rgba(210,220,255,0.30)";
    ctx.lineWidth = r*0.05;
    for(let i=0;i<6;i++){
      const a = (i/6)*Math.PI*2 + 0.2;
      ctx.beginPath();
      ctx.moveTo(x + Math.cos(a)*r*0.22, y + Math.sin(a)*r*0.12);
      ctx.lineTo(x + Math.cos(a)*r*0.80, y + Math.sin(a)*r*0.45);
      ctx.stroke();
    }
    // lights
    const pts=[];
    for(let i=0;i<10;i++){
      const a = (i/10)*Math.PI*2;
      pts.push({x:x+Math.cos(a)*r*0.95, y:y+Math.sin(a)*r*0.55, r:r*(0.06+R()*0.03)});
    }
    boltLights(pts,0.35);
  }

  // 2) Octagonal Hub
  function octagonalHub(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // octagon
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(-0.12);
    ctx.beginPath();
    for(let i=0;i<8;i++){
      const a = (i/8)*Math.PI*2;
      const rr = r*0.75;
      const px = Math.cos(a)*rr;
      const py = Math.sin(a)*rr*0.62;
      if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(200,215,255,0.25)";
    ctx.fill();
    ctx.strokeStyle = "rgba(220,230,255,0.45)";
    ctx.lineWidth = r*0.06;
    ctx.stroke();
    // docking arms
    ctx.strokeStyle = "rgba(220,230,255,0.30)";
    ctx.lineWidth = r*0.07;
    for(let i=0;i<3;i++){
      const a = (i/3)*Math.PI*2 + 0.4;
      ctx.beginPath();
      ctx.moveTo(Math.cos(a)*r*0.65, Math.sin(a)*r*0.40);
      ctx.lineTo(Math.cos(a)*r*1.05, Math.sin(a)*r*0.65);
      ctx.stroke();
    }
    ctx.restore();
    boltLights([{x:x+r*0.25,y:y-r*0.1,r:r*0.12},{x:x-r*0.3,y:y+r*0.15,r:r*0.10}],0.35);
  }

  // 3) Refinery (tanks + pipes)
  function refinery(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // main block
    ctx.fillStyle = "rgba(200,215,255,0.20)";
    ctx.fillRect(x-r*0.9,y-r*0.35,r*1.25,r*0.7);
    // tanks
    for(let i=0;i<3;i++){
      const tx = x + r*(0.55+i*0.18);
      const ty = y + r*( -0.18 + i*0.18);
      ctx.fillStyle = "rgba(210,230,255,0.22)";
      ctx.beginPath(); ctx.ellipse(tx,ty,r*0.22,r*0.14,0,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(220,230,255,0.35)";
      ctx.lineWidth=r*0.03;
      ctx.stroke();
    }
    // pipes
    ctx.strokeStyle="rgba(255,190,120,0.22)";
    ctx.lineWidth=r*0.05;
    ctx.beginPath();
    ctx.moveTo(x-r*0.2,y-r*0.15);
    ctx.bezierCurveTo(x+r*0.1,y-r*0.3, x+r*0.25,y, x+r*0.55,y-r*0.05);
    ctx.stroke();
    boltLights([{x:x+r*0.55,y:y-r*0.05,r:r*0.10}],0.28);
  }

  // 4) Shipyard (crane frame)
  function shipyard(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    ctx.strokeStyle="rgba(220,230,255,0.45)";
    ctx.lineWidth=r*0.07;
    // frame rectangle
    ctx.strokeRect(x-r*0.95,y-r*0.55,r*1.6,r*1.05);
    // gantry
    ctx.beginPath();
    ctx.moveTo(x-r*0.95,y-r*0.15);
    ctx.lineTo(x+r*0.65,y-r*0.15);
    ctx.stroke();
    // hanging arm
    ctx.lineWidth=r*0.04;
    ctx.beginPath();
    ctx.moveTo(x+r*0.25,y-r*0.15);
    ctx.lineTo(x+r*0.25,y+r*0.35);
    ctx.stroke();
    // small "ship" in bay
    ctx.fillStyle="rgba(140,220,255,0.18)";
    ctx.beginPath();
    ctx.ellipse(x-r*0.1,y+r*0.18,r*0.40,r*0.18,-0.1,0,Math.PI*2);
    ctx.fill();
    boltLights([{x:x+r*0.25,y:y+r*0.35,r:r*0.10}],0.35);
  }

  // 5) Antenna Array
  function antennaArray(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // base disc
    ctx.fillStyle="rgba(200,215,255,0.20)";
    ctx.beginPath(); ctx.arc(x,y,r*0.42,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="rgba(220,230,255,0.40)";
    ctx.lineWidth=r*0.05;
    ctx.stroke();
    // masts
    ctx.strokeStyle="rgba(220,230,255,0.45)";
    ctx.lineWidth=r*0.04;
    for(let i=0;i<5;i++){
      const a=(i/5)*Math.PI*2+0.2;
      ctx.beginPath();
      ctx.moveTo(x+Math.cos(a)*r*0.25, y+Math.sin(a)*r*0.12);
      ctx.lineTo(x+Math.cos(a)*r*0.85, y+Math.sin(a)*r*0.55);
      ctx.stroke();
      // dishes
      ctx.fillStyle="rgba(200,215,255,0.18)";
      ctx.beginPath();
      ctx.ellipse(x+Math.cos(a)*r*0.92, y+Math.sin(a)*r*0.60, r*0.16, r*0.10, a, 0, Math.PI*2);
      ctx.fill();
    }
    boltLights([{x:x,y:y-r*0.05,r:r*0.10}],0.32);
  }

  // 6) Fortress (spikes + armor)
  function fortress(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // armored core
    ctx.fillStyle="rgba(180,190,240,0.18)";
    ctx.beginPath();
    ctx.moveTo(x-r*0.65,y);
    ctx.lineTo(x-r*0.25,y-r*0.55);
    ctx.lineTo(x+r*0.55,y-r*0.20);
    ctx.lineTo(x+r*0.45,y+r*0.35);
    ctx.lineTo(x-r*0.10,y+r*0.55);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle="rgba(220,230,255,0.35)";
    ctx.lineWidth=r*0.05;
    ctx.stroke();
    // spikes
    ctx.strokeStyle="rgba(255,120,120,0.22)";
    ctx.lineWidth=r*0.05;
    for(let i=0;i<6;i++){
      const a=(i/6)*Math.PI*2;
      ctx.beginPath();
      ctx.moveTo(x+Math.cos(a)*r*0.55, y+Math.sin(a)*r*0.34);
      ctx.lineTo(x+Math.cos(a)*r*0.95, y+Math.sin(a)*r*0.60);
      ctx.stroke();
    }
    boltLights([{x:x+r*0.28,y:y-r*0.08,r:r*0.12}],0.30);
  }

  // 7) Garden Dome (transparent sphere)
  function gardenDome(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // base ring
    ctx.strokeStyle="rgba(220,230,255,0.35)";
    ctx.lineWidth=r*0.08;
    ctx.beginPath(); ctx.ellipse(x,y+r*0.20,r*0.75,r*0.25,0,0,Math.PI*2); ctx.stroke();
    // dome
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    const g=ctx.createRadialGradient(x-r*0.15,y-r*0.15,0, x,y,r*0.85);
    g.addColorStop(0,"rgba(160,255,220,0.22)");
    g.addColorStop(1,"rgba(160,255,220,0.02)");
    ctx.fillStyle=g;
    ctx.beginPath(); ctx.arc(x,y,r*0.78,0,Math.PI*2); ctx.fill();
    ctx.restore();
    // greenery hint
    ctx.fillStyle="rgba(60,200,120,0.18)";
    ctx.beginPath();
    ctx.ellipse(x-r*0.05,y+r*0.25,r*0.48,r*0.22,-0.15,0,Math.PI*2);
    ctx.fill();
    boltLights([{x:x-r*0.18,y:y-r*0.2,r:r*0.12}],0.30);
  }

  // 8) Scrapyard (debris cluster)
  function scrapyard(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    for(let i=0;i<18;i++){
      const px = x + (R()*2-1)*r*0.85;
      const py = y + (R()*2-1)*r*0.55;
      const w = r*(0.10+R()*0.22);
      const h = r*(0.06+R()*0.18);
      ctx.save();
      ctx.translate(px,py);
      ctx.rotate(R()*Math.PI);
      ctx.fillStyle = `rgba(200,215,255,${0.08+R()*0.18})`;
      ctx.fillRect(-w/2,-h/2,w,h);
      ctx.restore();
    }
    // central tug
    ctx.fillStyle="rgba(220,230,255,0.20)";
    ctx.beginPath(); ctx.ellipse(x,y,r*0.35,r*0.18,0.2,0,Math.PI*2); ctx.fill();
    boltLights([{x:x+r*0.05,y:y-r*0.05,r:r*0.10}],0.28);
  }

  // 9) Relay Beacon (thin + bright)
  function relayBeacon(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // mast
    ctx.strokeStyle="rgba(220,230,255,0.45)";
    ctx.lineWidth=r*0.05;
    ctx.beginPath();
    ctx.moveTo(x-r*0.75,y+r*0.25);
    ctx.lineTo(x+r*0.65,y-r*0.25);
    ctx.stroke();
    // nodes
    const pts=[];
    for(let i=0;i<4;i++){
      const t=i/3;
      const px = x-r*0.75 + t*(r*1.40);
      const py = y+r*0.25 + t*(-r*0.50);
      ctx.fillStyle="rgba(200,215,255,0.22)";
      ctx.beginPath(); ctx.arc(px,py,r*(0.08+0.02*i),0,Math.PI*2); ctx.fill();
      pts.push({x:px,y:py,r:r*(0.14+0.03*i)});
    }
    boltLights(pts,0.45);
  }

  // 10) Research Lab (modules + solar fins)
  function researchLab(x,y,r,seed){
    const R = rand(seed);
    metalFill(x,y,r,seed);
    // modules chain
    const mods = [
      {dx:-0.55,dy:-0.05,rr:0.20},
      {dx:-0.15,dy: 0.10,rr:0.26},
      {dx: 0.28,dy:-0.08,rr:0.18},
      {dx: 0.55,dy: 0.14,rr:0.14},
    ];
    for(const m of mods){
      const px=x+r*m.dx, py=y+r*m.dy, rr=r*m.rr;
      ctx.fillStyle="rgba(200,215,255,0.20)";
      ctx.beginPath(); ctx.arc(px,py,rr,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle="rgba(220,230,255,0.35)";
      ctx.lineWidth=r*0.03;
      ctx.stroke();
    }
    // solar fins
    ctx.strokeStyle="rgba(140,220,255,0.25)";
    ctx.lineWidth=r*0.06;
    ctx.beginPath();
    ctx.moveTo(x-r*0.55,y-r*0.45);
    ctx.lineTo(x-r*0.95,y-r*0.10);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x+r*0.35,y+r*0.50);
    ctx.lineTo(x+r*0.85,y+r*0.20);
    ctx.stroke();
    boltLights([{x:x-r*0.15,y:y+r*0.10,r:r*0.12}],0.30);
  }

  // draw
  addStars();

  const stations = [
    {name:"Ring Habitat", fn:ringHabitat},
    {name:"Octagonal Hub", fn:octagonalHub},
    {name:"Refinery", fn:refinery},
    {name:"Shipyard", fn:shipyard},
    {name:"Antenna Array", fn:antennaArray},
    {name:"Fortress", fn:fortress},
    {name:"Garden Dome", fn:gardenDome},
    {name:"Scrapyard", fn:scrapyard},
    {name:"Relay Beacon", fn:relayBeacon},
    {name:"Research Lab", fn:researchLab},
  ];

  const cols = 5, rows = 2;
  const cellW = c.width / cols;
  const cellH = c.height / rows;

  let idx = 0;
  for(let ry=0; ry<rows; ry++){
    for(let cx=0; cx<cols; cx++){
      const s = stations[idx++];
      const x = (cx+0.5)*cellW;
      const y = (ry+0.46)*cellH;
      const r = Math.min(cellW, cellH) * 0.24;

      shadow(x,y,r);
      s.fn(x,y,r, 9000 + idx*777);
      label(x,y,s.name);
    }
  }
</script>
</body>
</html>