<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Technicians â€“ Quantum Parts Demo</title>
  <style>
    body {
      margin: 0;
      background: #050814;
      color: #e5e9f0;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      margin: 10px 0 2px;
      font-size: 18px;
    }
    p {
      margin: 0 0 10px;
      font-size: 12px;
      opacity: 0.8;
    }
    canvas {
      background: radial-gradient(circle at 30% 10%, #1c263c 0, #050814 60%);
      border: 1px solid #333;
      margin: 12px;
      display: block;
    }
  </style>
</head>
<body>
  <h1>Technicians Quantum Parts</h1>
  <p>Quantum engine, wiggling scanner, lava-lamp reactor, sharp concentric wings.</p>
  <canvas id="techParts" width="900" height="500"></canvas>

  <script>
    // Command (terminal): npx serve .   // then open http://localhost:3000/this-file.html

    const canvas = document.getElementById('techParts');
    const ctx = canvas.getContext('2d');
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    function withTransform(ctx, x, y, sx, sy, rot, fn) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot || 0);
      ctx.scale(sx, sy);
      fn(ctx);
      ctx.restore();
    }

    // Precomputed starfield
    const stars = Array.from({ length: 180 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: Math.random() * 1.3 + 0.2,
      a: 0.4 + Math.random() * 0.6
    }));

    function drawStarfield(t) {
      ctx.save();
      ctx.fillStyle = '#050814';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      stars.forEach(s => {
        const twinkle = s.a * (0.8 + 0.2 * Math.sin(t * 2 + s.x * 0.01));
        ctx.globalAlpha = twinkle;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
      ctx.restore();
    }

    // 1) Quantum entanglement engine (3 glowing rotating ellipses)
    function drawQuantumEngine(ctx, t) {
      ctx.save();

      // metallic hub
      const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 22);
      hubGrad.addColorStop(0, '#e5f2ff');
      hubGrad.addColorStop(1, '#4c566a');
      ctx.fillStyle = hubGrad;
      ctx.strokeStyle = '#d8dee9';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, 22, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // inner dark core
      ctx.fillStyle = '#11151e';
      ctx.beginPath();
      ctx.arc(0, 0, 10, 0, Math.PI * 2);
      ctx.fill();

      // 3 entangled, rotating glowing ellipses
      ctx.globalCompositeOperation = 'lighter';
      const phases = [0, (2 * Math.PI) / 3, (4 * Math.PI) / 3];
      phases.forEach((phase, i) => {
        ctx.save();
        const angle = t * 1.2 + phase;
        ctx.rotate(angle);

        const g = ctx.createLinearGradient(-40, 0, 40, 0);
        const hue = 180 + i * 40;
        g.addColorStop(0, `hsla(${hue}, 80%, 60%, 0)`);
        g.addColorStop(0.5, `hsla(${hue}, 90%, 75%, 0.9)`);
        g.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);

        ctx.strokeStyle = g;
        ctx.lineWidth = 4;

        ctx.beginPath();
        ctx.ellipse(0, 0, 40, 14, 0, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      });

      // tiny blinking core
      const coreGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
      coreGlow.addColorStop(0, 'rgba(255,255,255,0.9)');
      coreGlow.addColorStop(1, 'rgba(255,255,255,0)');
      ctx.fillStyle = coreGlow;
      ctx.beginPath();
      ctx.arc(0, 0, 14, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    // 2) Rotating scanner with wiggling antenna
    function drawWigglingScanner(ctx, t) {
      ctx.save();

      // base
      const baseGrad = ctx.createLinearGradient(-18, 12, 18, -12);
      baseGrad.addColorStop(0, '#4c566a');
      baseGrad.addColorStop(1, '#2e3440');
      ctx.fillStyle = baseGrad;
      ctx.strokeStyle = '#d8dee9';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.roundRect(-18, -10, 36, 20, 6);
      ctx.fill();
      ctx.stroke();

      // rotating plate
      ctx.save();
      const spin = t * 1.5;
      ctx.translate(0, -6);
      ctx.rotate(spin);

      ctx.fillStyle = '#e5f2ff';
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();

      // wiggling antenna
      ctx.save();
      ctx.translate(0, -18);
      ctx.strokeStyle = '#88c0ff';
      ctx.lineWidth = 2;

      const segments = 6;
      const segLen = 6;
      let x = 0, y = 0;
      ctx.beginPath();
      ctx.moveTo(x, y);
      for (let i = 1; i <= segments; i++) {
        const wiggle = Math.sin(t * 4 + i * 0.9) * 3;
        x = wiggle;
        y = -segLen * i;
        ctx.lineTo(x, y);
      }
      ctx.stroke();

      // antenna tip glow
      ctx.globalCompositeOperation = 'lighter';
      const tipG = ctx.createRadialGradient(x, y, 0, x, y, 6);
      tipG.addColorStop(0, 'rgba(140,220,255,1)');
      tipG.addColorStop(1, 'rgba(140,220,255,0)');
      ctx.fillStyle = tipG;
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();

      ctx.restore();
    }

    // 3) Reactor (lava lamp style)
    const blobs = Array.from({ length: 5 }, (_, i) => ({
      phase: Math.random() * Math.PI * 2,
      height: 0.2 + Math.random() * 0.6,
      radius: 6 + Math.random() * 4,
      offsetX: (Math.random() - 0.5) * 10
    }));

    function drawLavaReactor(ctx, t) {
      ctx.save();

      // container
      ctx.fillStyle = '#2e3440';
      ctx.beginPath();
      ctx.roundRect(-20, -40, 40, 80, 10);
      ctx.fill();

      // inner glass
      ctx.fillStyle = '#11141c';
      ctx.beginPath();
      ctx.roundRect(-14, -34, 28, 68, 8);
      ctx.fill();

      // glowing lava blobs
      ctx.save();
      ctx.beginPath();
      ctx.rect(-14, -34, 28, 68);
      ctx.clip();

      ctx.globalCompositeOperation = 'lighter';
      blobs.forEach(b => {
        const yNorm = 0.5 + 0.5 * Math.sin(t * 0.7 + b.phase);
        const y = -34 + yNorm * 68;
        const r = b.radius * (0.7 + 0.3 * Math.sin(t * 1.1 + b.phase));
        const x = b.offsetX;

        const g = ctx.createRadialGradient(x, y, 0, x, y, r);
        g.addColorStop(0, 'rgba(255,200,120,0.95)');
        g.addColorStop(1, 'rgba(255,150,80,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      });

      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();

      // top cap
      ctx.fillStyle = '#4c566a';
      ctx.beginPath();
      ctx.roundRect(-16, -46, 32, 10, 4);
      ctx.fill();

      // bottom cap
      ctx.beginPath();
      ctx.roundRect(-16, 36, 32, 10, 4);
      ctx.fill();

      ctx.restore();
    }

    // 4) Adaptive sharp wings (8 sets of sharp concentric wings)
    function drawSharpWings(ctx, t) {
      ctx.save();

      // central node
      const hubGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 18);
      hubGrad.addColorStop(0, '#e5f2ff');
      hubGrad.addColorStop(1, '#4c566a');
      ctx.fillStyle = hubGrad;
      ctx.strokeStyle = '#d8dee9';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, 0, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // openness: 0 (tight) -> 1 (open)
      const openness = (Math.sin(t * 0.8) + 1) / 2;

      const ringCount = 8;
      for (let ring = 0; ring < ringCount; ring++) {
        const factor = (ring + 1) / ringCount;
        const baseLen = 60 + 40 * factor;
        const length = baseLen * (0.4 + openness * 0.6);
        const baseWidth = 10 + 8 * factor;
        const width = baseWidth * (0.5 + (1 - openness) * 0.7);

        const colorFactor = 0.4 + factor * 0.6;
        ctx.strokeStyle = `rgba(136,192,208,${colorFactor})`;
        ctx.lineWidth = 1 + factor * 1.2;

        const blades = 4;
        for (let i = 0; i < blades; i++) {
          const angle = (Math.PI * 2 / blades) * i + t * 0.15 * (ring % 2 === 0 ? 1 : -1);
          ctx.save();
          ctx.rotate(angle);

          ctx.beginPath();
          ctx.moveTo(12 + ring * 4, -width / 2);
          ctx.lineTo(12 + ring * 4 + length, 0);
          ctx.lineTo(12 + ring * 4, width / 2);
          ctx.closePath();
          ctx.stroke();

          ctx.restore();
        }
      }

      ctx.restore();
    }

    // main loop
    let lastTime = 0;
    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const t = timestamp / 1000;

      drawStarfield(t);

      // Layout:
      // Quantum engine (left)
      withTransform(ctx, cx - 250, cy - 40, 1.3, 1.3, 0, c => drawQuantumEngine(c, t));
      // Scanner (top-right)
      withTransform(ctx, cx + 230, cy - 120, 1.2, 1.2, 0, c => drawWigglingScanner(c, t));
      // Reactor (bottom-right)
      withTransform(ctx, cx + 230, cy + 90, 1.4, 1.4, 0, c => drawLavaReactor(c, t));
      // Sharp wings (center)
      withTransform(ctx, cx, cy + 10, 1, 1, 0, c => drawSharpWings(c, t));

      // Labels
      ctx.fillStyle = '#e5e9f0';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Technician Quantum Entanglement Engine', cx - 250, cy + 70);
      ctx.fillText('Rotating Scanner (Wiggling Antenna)', cx + 230, cy - 50);
      ctx.fillText('Reactor Outfit (Lava Lamp)', cx + 230, cy + 165);
      ctx.fillText('Adaptive Sharp Concentric Wings', cx, cy + 90);

      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
</body>
</html>