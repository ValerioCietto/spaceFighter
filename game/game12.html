<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>SpaceFighter</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0" />
  <link rel="stylesheet" href="game.css">
  <link rel="stylesheet" href="station.css">
</head>
<body>
  <div id="game-container">
    <canvas id="game-canvas"></canvas>

    <!-- Station UI -->
    <div class="station-overlay" id="station-overlay" aria-hidden="true">
      <div class="station-dialog" role="dialog" aria-modal="true">
        <div class="station-dialog-header">
          <h2 class="station-title" id="station-title">Station</h2>
          <button class="station-exit-btn" id="station-exit-btn" type="button">Exit Station</button>
        </div>
        <div class="station-dialog-body">
          <div class="station-dialog-content" id="station-content">
            <!-- Populated by station-manager.js -->
          </div>
          <div class="station-tabs">
            <button class="station-tab-btn active" data-tab="info" type="button">Info</button>
            <button class="station-tab-btn" data-tab="outfitter" type="button">Outfitter</button>
            <button class="station-tab-btn" data-tab="finance" type="button">Finance</button>
            <button class="station-tab-btn" data-tab="spaceships" type="button">Spaceships</button>
          </div>
        </div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div class="hud-row">
        <span class="label">Velocità:</span>
        <span class="value" id="speed-value">0.0</span>
        <span class="label">px/s</span>
      </div>
      <div class="hud-row">
        <span class="label">Pos:</span>
        <span class="value" id="pos-value">0, 0</span>
      </div>
      <div class="hud-row">
        <span class="label">Money:</span>
        <span class="value money-value" id="money-value">0§</span>
      </div>
    </div>

    <div id="minimap">
      <canvas id="minimap-canvas"></canvas>
    </div>

    <!-- Dock button sotto alla minimappa -->
    <button id="dock-button" type="button">Dock</button>

    <div id="touch-controls">
      <div class="touch-group">
        <div class="touch-btn" data-action="left">←</div>
        <div class="touch-btn" data-action="right">→</div>
      </div>
      <div class="touch-group">
        <div class="touch-btn primary" data-action="fire">●</div>
        <div class="touch-btn" data-action="lock">◎</div>
        <div class="touch-btn" data-action="weapon-cycle">↺</div>
      </div>
      <div class="touch-group touch-column">
        <div class="touch-btn primary" data-action="thrust">▲</div>
        <div class="touch-btn" data-action="brake">▼</div>
      </div>
    </div>
  </div>

  <!-- station logic -->
  <script src="station-manager.js"></script>
  <!-- input (keyboard + touch) -->
  <script src="input.js"></script>

  <script>
    // Command to launch: `npx serve .` then open http://localhost:3000/game.html in a browser

    (function () {
      const SECTOR_SIZE = 6000;         // world size (square for simplicity)
      const STAR_DIAMETER = 300;        // minimap star diameter in world units
      const STAR_RADIUS_WORLD = 100;    // main canvas star radius in px
      const STAR_X = 3000;              // star world X
      const STAR_Y = 3000;              // star world Y

      // Simple station position near the star
      const STATION_X = STAR_X + 600;
      const STATION_Y = STAR_Y;
      const STATION_ROT_SPEED = Math.PI / 16; // rad/s, slow rotation

      const SystemInfo = {
        name: "Solar",
        size: 6000,
        stars: [
          {
            name: "Sun",
            position_x: STAR_X,
            position_y: STAR_Y,
            radius: STAR_RADIUS_WORLD
          }
        ],
        planets: [],
        stations: [
          {
            name: "Orbital Trade Hub",
            position_x: STATION_X,
            position_y: STATION_Y
          }
        ]
      };

      const MAX_SPEED = 150;            // px / second
      const ACCELERATION = 100;         // px / s^2
      const FRICTION = 70;              // px / s^2
      const ROTATION_SPEED = Math.PI;   // rad/s (~180°/s)

      const STORAGE_KEY = "spaceSectorState_v2";

      const MONEY_PER_TARGET = 10;

      // Weapons definitions
      const WeaponSpaceBullet = {
        name: "Space Bullet",
        damage: 1,
        base_speed: 250,
        life_span: 3.0,
        spread: 0.15,          // degrees
        projectiles: 1,
        aspect: "round_bullet",
        delay_ms: 50
      };

      const WeaponSniper = {
        name: "Sniper",
        damage: 10,
        base_speed: 1000,
        life_span: 5.0,
        spread: 0.0,           // degrees
        projectiles: 1,
        aspect: "line",
        auto_aim: 1.0,         // radians
        delay_ms: 500
      };

      const WeaponShotgun = {
        name: "Shotgun",
        damage: 2,
        base_speed: 350,
        acceleration: -75,
        life_span: 2.0,
        spread: 5.0,           // degrees
        projectiles: 5,
        aspect: "bullet",
        delay_ms: 200
      };

      const WeaponHomingMissiles = {
        name: "Homing missiles",
        damage: 5,
        base_speed: 100,
        acceleration: 10,
        max_speed: 200,
        turning_speed_deg: 120,      // deg/sec
        life_span: 20.0,
        spread: 3.0,                // degrees
        projectiles: 1,
        aspect: "missile",
        delay_ms: 1000,
        homing: true
      };
      WeaponHomingMissiles.turn_speed_rad =
        WeaponHomingMissiles.turning_speed_deg * Math.PI / 180;

      const weapons = [
        WeaponSpaceBullet,
        WeaponSniper,
        WeaponShotgun,
        WeaponHomingMissiles
      ];
      let currentWeaponIndex = 0;
      const weaponLastFire = [0, 0, 0, 0];

      const canvas = document.getElementById("game-canvas");
      const ctx = canvas.getContext("2d");

      const minimapCanvas = document.getElementById("minimap-canvas");
      const minimapCtx = minimapCanvas.getContext("2d");

      const speedValueEl = document.getElementById("speed-value");
      const posValueEl = document.getElementById("pos-value");
      const moneyValueEl = document.getElementById("money-value");

      const touchButtons = document.querySelectorAll(".touch-btn");
      const lockButton = document.querySelector('.touch-btn[data-action="lock"]');
      const dockButtonEl = document.getElementById("dock-button");

      let width = 0;
      let height = 0;

      let minimapSize = 0;
      let minimapScale = 0;

      const state = {
        x: SECTOR_SIZE / 2,
        y: SECTOR_SIZE / 2,
        vx: 0,
        vy: 0,
        angle: -Math.PI / 2, // facing up
        money: 0
      };

      const input = {
        left: false,
        right: false,
        thrust: false,
        brake: false
      };

      let lineToTarget = false;
      let stationAngle = 0;

      const projectiles = [];
      let target = null;

      function spawnTarget() {
        const centerX = SECTOR_SIZE / 2;
        const centerY = SECTOR_SIZE / 2;
        const maxR = 500;
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * maxR;
        const radius = 10 + Math.random() * 30;
        const targetHp = 1 + Math.random() * 9;

        target = {
          x: centerX + Math.cos(angle) * r,
          y: centerY + Math.sin(angle) * r,
          radius,
          hp: targetHp
        };
      }

      function normalizeAngleDiff(diff) {
        diff = (diff + Math.PI) % (2 * Math.PI);
        if (diff < 0) diff += 2 * Math.PI;
        return diff - Math.PI;
      }

      function attemptFireWeapon() {
        const weapon = weapons[currentWeaponIndex];
        const now = performance.now();
        const last = weaponLastFire[currentWeaponIndex] || 0;

        if (now - last < weapon.delay_ms) {
          return;
        }
        weaponLastFire[currentWeaponIndex] = now;

        let baseAngle = state.angle;
        if (weapon.auto_aim && target) {
          const toTargetAngle = Math.atan2(target.y - state.y, target.x - state.x);
          let diff = normalizeAngleDiff(toTargetAngle - state.angle);
          if (Math.abs(diff) <= weapon.auto_aim) {
            baseAngle = toTargetAngle;
          }
        }

        const spreadRad = (weapon.spread || 0) * Math.PI / 180;
        const muzzleDistance = 18;
        const shipSpeedX = state.vx;
        const shipSpeedY = state.vy;

        const count = weapon.projectiles || 1;

        for (let i = 0; i < count; i++) {
          const offset = spreadRad > 0
            ? (-spreadRad + Math.random() * (2 * spreadRad))
            : 0;

          const angle = baseAngle + offset;
          const dirX = Math.cos(angle);
          const dirY = Math.sin(angle);

          let vx, vy, speed;

          if (weapon.homing) {
            speed = weapon.base_speed;
            vx = dirX * speed;
            vy = dirY * speed;
          } else {
            speed = weapon.base_speed;
            vx = shipSpeedX + dirX * weapon.base_speed;
            vy = shipSpeedY + dirY * weapon.base_speed;
          }

          const startX = state.x + dirX * muzzleDistance;
          const startY = state.y + dirY * muzzleDistance;

          projectiles.push({
            x: startX,
            y: startY,
            vx,
            vy,
            age: 0,
            life: weapon.life_span,
            damage: weapon.damage,
            aspect: weapon.aspect,
            angle,
            homing: !!weapon.homing,
            speed: speed,
            accel: weapon.acceleration || 0,
            maxSpeed: weapon.max_speed || weapon.base_speed || 0,
            turnSpeed: weapon.turn_speed_rad || 0
          });
        }
      }

      function cycleWeapon() {
        currentWeaponIndex = (currentWeaponIndex + 1) % weapons.length;
      }

      function updateLockButtonVisual() {
        if (!lockButton) return;
        if (lineToTarget) {
          lockButton.classList.add("toggled");
        } else {
          lockButton.classList.remove("toggled");
        }
      }

      function requestDock() {
        // Docking “gestionale”: apertura station dialog
        StationManager.openStation({
          name: "Orbital Trade Hub",
          systemInfo: SystemInfo
        });
      }

      if (dockButtonEl) {
        dockButtonEl.addEventListener("click", (e) => {
          e.preventDefault();
          requestDock();
        });
      }

      // STARFIELD
      const starLayers = [];
      const NUM_LAYERS = 3;
      const STARS_PER_LAYER = 80;

      function initStarfield() {
        starLayers.length = 0;
        for (let i = 0; i < NUM_LAYERS; i++) {
          const factor = 0.2 + i * 0.3;
          const stars = [];
          for (let s = 0; s < STARS_PER_LAYER; s++) {
            stars.push({
              x: Math.random() * SECTOR_SIZE * 2 - SECTOR_SIZE,
              y: Math.random() * SECTOR_SIZE * 2 - SECTOR_SIZE
            });
          }
          starLayers.push({ factor, stars });
        }
      }

      function resize() {
        width = canvas.clientWidth;
        height = canvas.clientHeight;

        const dpr = window.devicePixelRatio || 1;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const minimapContainer = document.getElementById("minimap");
        minimapSize = Math.min(
          minimapContainer.clientWidth,
          minimapContainer.clientHeight
        );

        minimapCanvas.width = minimapSize * dpr;
        minimapCanvas.height = minimapSize * dpr;
        minimapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

        minimapScale = (minimapSize * 0.8) / SECTOR_SIZE;
      }

      window.addEventListener("resize", resize);

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return;
          const saved = JSON.parse(raw);
          ["x", "y", "vx", "vy", "angle", "money"].forEach((k) => {
            if (typeof saved[k] === "number") state[k] = saved[k];
          });
        } catch (e) {
          console.warn("Impossibile caricare lo stato:", e);
        }
        moneyValueEl.textContent = `${state.money.toFixed(0)}§`;
      }

      function saveState() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
          console.warn("Impossibile salvare lo stato:", e);
        }
      }

      function update(dt) {
        if (input.left) {
          state.angle -= ROTATION_SPEED * dt;
        }
        if (input.right) {
          state.angle += ROTATION_SPEED * dt;
        }

        let speed = Math.hypot(state.vx, state.vy);

        if (input.thrust) {
          const ax = Math.cos(state.angle) * ACCELERATION;
          const ay = Math.sin(state.angle) * ACCELERATION;
          state.vx += ax * dt;
          state.vy += ay * dt;
        }

        if (!input.thrust) {
          if (speed > 0) {
            const decel = FRICTION * dt;
            speed = Math.max(0, speed - decel);
            if (speed === 0) {
              state.vx = 0;
              state.vy = 0;
            } else {
              const factor = speed / Math.hypot(state.vx, state.vy);
              state.vx *= factor;
              state.vy *= factor;
            }
          }
        }

        if (input.brake && speed > 0) {
          const decel = ACCELERATION * dt;
          speed = Math.max(0, speed - decel);
          if (speed === 0) {
            state.vx = 0;
            state.vy = 0;
          } else {
            const factor = speed / Math.hypot(state.vx, state.vy);
            state.vx *= factor;
            state.vy *= factor;
          }
        }

        const newSpeed = Math.hypot(state.vx, state.vy);
        if (newSpeed > MAX_SPEED) {
          const factor = MAX_SPEED / newSpeed;
          state.vx *= factor;
          state.vy *= factor;
        }

        state.x += state.vx * dt;
        state.y += state.vy * dt;

        state.x = Math.max(0, Math.min(SECTOR_SIZE, state.x));
        state.y = Math.max(0, Math.min(SECTOR_SIZE, state.y));

        // station rotation
        stationAngle += STATION_ROT_SPEED * dt;

        // Update projectiles
        for (let i = projectiles.length - 1; i >= 0; i--) {
          const p = projectiles[i];
          p.age += dt;

          if (p.homing && target) {
            const desiredAngle = Math.atan2(target.y - p.y, target.x - p.x);
            let diff = normalizeAngleDiff(desiredAngle - p.angle);
            const maxTurn = p.turnSpeed * dt;
            if (diff > maxTurn) diff = maxTurn;
            if (diff < -maxTurn) diff = -maxTurn;
            p.angle += diff;

            p.speed = Math.min(p.maxSpeed || p.speed, p.speed + p.accel * dt);

            p.vx = Math.cos(p.angle) * p.speed;
            p.vy = Math.sin(p.angle) * p.speed;
          }

          p.x += p.vx * dt;
          p.y += p.vy * dt;

          let remove = false;

          if (p.age > (p.life || 3.0)) {
            remove = true;
          }

          if (!remove && target) {
            const dx = p.x - target.x;
            const dy = p.y - target.y;
            const dist = Math.hypot(dx, dy);
            if (dist <= target.radius) {
              const damage = p.damage || 1;
              target.hp -= damage;
              remove = true;
              if (target.hp <= 0) {
                state.money += MONEY_PER_TARGET;
                moneyValueEl.textContent = `${state.money.toFixed(0)}§`;
                spawnTarget();
              }
            }
          }

          if (remove) {
            projectiles.splice(i, 1);
          }
        }

        // Dock button blink when within 500px of station
        if (dockButtonEl) {
          const dxStation = state.x - STATION_X;
          const dyStation = state.y - STATION_Y;
          const distStation = Math.hypot(dxStation, dyStation);

          if (distStation <= 500) {
            dockButtonEl.classList.add("blink");
          } else {
            dockButtonEl.classList.remove("blink");
          }
        }

        speedValueEl.textContent = newSpeed.toFixed(1);
        posValueEl.textContent = `${state.x.toFixed(0)}, ${state.y.toFixed(0)}`;
      }

      function drawStarfield() {
        ctx.save();
        ctx.fillStyle = "#020309";
        ctx.fillRect(0, 0, width, height);

        const camX = state.x;
        const camY = state.y;

        starLayers.forEach((layer, idx) => {
          const { factor, stars } = layer;
          const size = 2 + idx;

          stars.forEach((star) => {
            const sx = (star.x - camX * factor) % (SECTOR_SIZE * 2);
            const sy = (star.y - camY * factor) % (SECTOR_SIZE * 2);
            let x = sx;
            let y = sy;
            if (x < -SECTOR_SIZE) x += SECTOR_SIZE * 2;
            if (y < -SECTOR_SIZE) y += SECTOR_SIZE * 2;

            const screenX = width / 2 + x * 0.1;
            const screenY = height / 2 + y * 0.1;

            if (screenX < -20 || screenX > width + 20 || screenY < -20 || screenY > height + 20) return;

            const alpha = 0.3 + layer.factor * 0.5;
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size * 0.4, 0, Math.PI * 2);
            ctx.fill();
          });
        });

        ctx.restore();
      }

      function drawMainStar() {
        const screenX = width / 2 + (STAR_X - state.x);
        const screenY = height / 2 + (STAR_Y - state.y);

        const radius = STAR_RADIUS_WORLD;

        ctx.save();
        const gradient = ctx.createRadialGradient(
          screenX,
          screenY,
          0,
          screenX,
          screenY,
          radius
        );
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(0.3, "#fff9c4");
        gradient.addColorStop(1, "rgba(255,255,255,0)");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, screenY, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function drawStation() {
        const screenX = width / 2 + (STATION_X - state.x);
        const screenY = height / 2 + (STATION_Y - state.y);

        const baseRadius = 32;

        ctx.save();
        ctx.translate(screenX, screenY);
        ctx.rotate(stationAngle);

        // octagon core
        ctx.beginPath();
        const sides = 8;
        for (let i = 0; i < sides; i++) {
          const a = (Math.PI * 2 * i) / sides;
          const x = Math.cos(a) * baseRadius;
          const y = Math.sin(a) * baseRadius;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.fillStyle = "#9e9e9e";
        ctx.fill();
        ctx.strokeStyle = "#cfd8dc";
        ctx.lineWidth = 2;
        ctx.stroke();

        // semicircle decorator on top
        const decoRadius = baseRadius * 0.8;
        ctx.beginPath();
        ctx.arc(0, -baseRadius, decoRadius, Math.PI, 0, true);
        ctx.fillStyle = "#b0bec5";
        ctx.fill();

        // 5 small spikes for services
        const spikes = 5;
        const spikeRadius = decoRadius + 6;
        for (let i = 0; i < spikes; i++) {
          const t = (i / (spikes - 1)) - 0.5; // from -0.5 to +0.5
          const angle = -Math.PI / 2 + t * (Math.PI / 2); // distribute across top semicircle
          const sx = Math.cos(angle) * spikeRadius;
          const sy = Math.sin(angle) * spikeRadius - baseRadius * 0.3;

          ctx.beginPath();
          ctx.moveTo(sx, sy - 3);
          ctx.lineTo(sx + 4, sy + 4);
          ctx.lineTo(sx - 4, sy + 4);
          ctx.closePath();
          ctx.fillStyle = "#eceff1";
          ctx.fill();
        }

        ctx.restore();
      }

      function drawTarget() {
        if (!target) return;

        const screenX = width / 2 + (target.x - state.x);
        const screenY = height / 2 + (target.y - state.y);

        ctx.save();
        ctx.beginPath();
        ctx.arc(screenX, screenY, target.radius, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(76, 175, 80, 0.3)";
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = "#4caf50";
        ctx.stroke();

        const hpRatio = target.hp / 10;
        ctx.beginPath();
        ctx.strokeStyle = "#c8e6c9";
        ctx.lineWidth = 3;
        ctx.arc(
          screenX,
          screenY,
          target.radius + 6,
          -Math.PI / 2,
          -Math.PI / 2 + hpRatio * Math.PI * 2
        );
        ctx.stroke();

        ctx.restore();
      }

      function drawTargetLine() {
        if (!lineToTarget || !target) return;

        const shipX = width / 2;
        const shipY = height / 2;
        const targetX = width / 2 + (target.x - state.x);
        const targetY = height / 2 + (target.y - state.y);

        const dx = targetX - shipX;
        const dy = targetY - shipY;
        const dist = Math.hypot(dx, dy);
        if (dist < 1) return;

        const dirX = dx / dist;
        const dirY = dy / dist;

        const startX = shipX + dirX * 25;
        const startY = shipY + dirY * 25;

        const REF_DIST = 400;
        const t = Math.min(1, dist / REF_DIST);
        const length = 10 + (60 - 10) * t;

        const endX = startX + dirX * length;
        const endY = startY + dirY * length;

        ctx.save();
        ctx.strokeStyle = "#ff5252";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.restore();
      }

      function drawProjectiles() {
        if (!projectiles.length) return;

        ctx.save();

        projectiles.forEach((p) => {
          const screenX = width / 2 + (p.x - state.x);
          const screenY = height / 2 + (p.y - state.y);

          const aspect = p.aspect || "bullet";

          if (aspect === "line") {
            const len = 10;
            const ax = Math.cos(p.angle) * len;
            const ay = Math.sin(p.angle) * len;
            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            ctx.lineTo(screenX + ax, screenY + ay);
            ctx.stroke();
          } else if (aspect === "missile") {
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(p.angle);

            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.moveTo(8, 0);
            ctx.lineTo(-6, -3);
            ctx.lineTo(-4, 0);
            ctx.lineTo(-6, 3);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = "#ff5252";
            ctx.beginPath();
            ctx.moveTo(-4, -3);
            ctx.lineTo(-8, -5);
            ctx.lineTo(-4, -1);
            ctx.closePath();
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(-4, 3);
            ctx.lineTo(-8, 5);
            ctx.lineTo(-4, 1);
            ctx.closePath();
            ctx.fill();

            ctx.restore();
          } else {
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.arc(screenX, screenY, 3, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        ctx.restore();
      }

      function drawShip() {
        ctx.save();
        ctx.translate(width / 2, height / 2);
        ctx.rotate(state.angle);

        ctx.beginPath();
        ctx.moveTo(14, 0);
        ctx.lineTo(-10, -8);
        ctx.lineTo(-3, 0);
        ctx.lineTo(-10, 8);
        ctx.closePath();
        ctx.fillStyle = "#ffffff";
        ctx.fill();

        ctx.strokeStyle = "#4fc3f7";
        ctx.lineWidth = 2;
        ctx.stroke();

        const speed = Math.hypot(state.vx, state.vy);
        if (speed > 0.1 && !input.thrust) {
          ctx.save();
          ctx.rotate(Math.PI);
          ctx.beginPath();
          ctx.moveTo(10, -3);
          ctx.lineTo(18, 0);
          ctx.lineTo(10, 3);
          ctx.closePath();
          ctx.fillStyle = "#ff9800";
          ctx.fill();
          ctx.restore();
        }

        if (input.thrust && speed > 0.1) {
          ctx.save();
          ctx.rotate(Math.PI);
          ctx.beginPath();
          ctx.moveTo(12, -4);
          ctx.lineTo(22, 0);
          ctx.lineTo(12, 4);
          ctx.closePath();
          ctx.fillStyle = "#ffeb3b";
          ctx.fill();
          ctx.restore();
        }

        ctx.restore();
      }

      function drawMinimap() {
        const w = minimapSize;
        const h = minimapSize;

        minimapCtx.clearRect(0, 0, w, h);

        minimapCtx.save();
        minimapCtx.translate(w / 2, h / 2);

        const hexRadius = (SECTOR_SIZE / 2) * minimapScale;
        minimapCtx.beginPath();
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 3) * i - Math.PI / 2;
          const x = hexRadius * Math.cos(a);
          const y = hexRadius * Math.sin(a);
          if (i === 0) minimapCtx.moveTo(x, y);
          else minimapCtx.lineTo(x, y);
        }
        minimapCtx.closePath();
        minimapCtx.strokeStyle = "rgba(255,255,255,0.4)";
        minimapCtx.lineWidth = 1;
        minimapCtx.stroke();

        const starRadius = (STAR_DIAMETER / 2) * minimapScale;
        minimapCtx.beginPath();
        minimapCtx.arc(0, 0, starRadius, 0, Math.PI * 2);
        const grd = minimapCtx.createRadialGradient(0, 0, 0, 0, 0, starRadius);
        grd.addColorStop(0, "#ffffff");
        grd.addColorStop(1, "rgba(255,255,255,0.1)");
        minimapCtx.fillStyle = grd;
        minimapCtx.fill();

        // station on minimap
        const stx = (STATION_X - SECTOR_SIZE / 2) * minimapScale;
        const sty = (STATION_Y - SECTOR_SIZE / 2) * minimapScale;
        minimapCtx.beginPath();
        minimapCtx.arc(stx, sty, 3, 0, Math.PI * 2);
        minimapCtx.fillStyle = "#b0bec5";
        minimapCtx.fill();

        // Target on minimap as red 5px dot
        if (target) {
          const tx = (target.x - SECTOR_SIZE / 2) * minimapScale;
          const ty = (target.y - SECTOR_SIZE / 2) * minimapScale;
          minimapCtx.beginPath();
          minimapCtx.arc(tx, ty, 2.5, 0, Math.PI * 2);
          minimapCtx.fillStyle = "#ff5252";
          minimapCtx.fill();
        }

        const sx = (state.x - SECTOR_SIZE / 2) * minimapScale;
        const sy = (state.y - SECTOR_SIZE / 2) * minimapScale;

        minimapCtx.save();
        minimapCtx.translate(sx, sy);
        minimapCtx.rotate(state.angle);

        minimapCtx.beginPath();
        minimapCtx.moveTo(6, 0);
        minimapCtx.lineTo(-4, -3);
        minimapCtx.lineTo(-4, 3);
        minimapCtx.closePath();
        minimapCtx.fillStyle = "#4fc3f7";
        minimapCtx.fill();

        minimapCtx.restore();
        minimapCtx.restore();
      }

      let lastTime = performance.now();

      function loop(now) {
        const dt = Math.min(0.05, (now - lastTime) / 1000);
        lastTime = now;

        update(dt);
        drawStarfield();
        drawMainStar();
        drawStation();
        drawTarget();
        drawTargetLine();
        drawProjectiles();
        drawShip();
        drawMinimap();

        requestAnimationFrame(loop);
      }

      function init() {
        resize();
        initStarfield();
        loadState();
        spawnTarget();
        updateLockButtonVisual();

        StationManager.init({
          systemInfo: SystemInfo,
          getPlayerState: () => state
        });

        setupInput(
          input,
          attemptFireWeapon,
          () => {
            lineToTarget = !lineToTarget;
            updateLockButtonVisual();
          },
          cycleWeapon,
          (idx) => { currentWeaponIndex = idx; },
          touchButtons
        );

        setInterval(saveState, 2000);
        lastTime = performance.now();
        requestAnimationFrame(loop);
      }

      window.addEventListener("load", init);
    })();
  </script>
</body>
</html>
