<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Starfighter – Parallax Sector Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <style>
    :root{
      --bg:#020617;
      --ink:#e5e7eb;
      --panel:#020617dd;
      --border:#1f2937;
      --accent:#38bdf8;
    }
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;overflow:hidden}
    #game{
      position:fixed;inset:0;width:100%;height:100%;display:block;
      background:#020617;
    }
    #minimap{
      position:fixed;top:8px;right:8px;
      width:160px;height:160px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
    }
    .hud-label{
      position:fixed;top:10px;left:10px;
      font-size:12px;
      background:#020617aa;
      padding:4px 8px;
      border-radius:8px;
      border:1px solid #1f2937;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="minimap"></canvas>
  <div class="hud-label">← → sterza · ↑ accelera · ↓ frena</div>

  <script>
  // run with: npx http-server .

  (function(){
    const game = document.getElementById('game');
    const gctx = game.getContext('2d', { alpha:false, desynchronized:true });
    const minimap = document.getElementById('minimap');
    const mctx = minimap.getContext('2d');

    let DPR = 1, W = 0, H = 0;

    function resize(){
      DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      W = Math.floor(window.innerWidth * DPR);
      H = Math.floor(window.innerHeight * DPR);
      game.width = W; game.height = H;
      game.style.width = '100%'; game.style.height = '100%';

      minimap.width = minimap.clientWidth * DPR;
      minimap.height = minimap.clientHeight * DPR;

      buildStars();
    }
    window.addEventListener('resize', resize, { passive:true });
    resize();

    // ---------- Nave / fisica ----------
    const SHIP_SIZE = 40 * DPR;
    const THRUST = 500 * DPR;       // px/s^2
    const BRAKE = 450 * DPR;
    const ANG_SPEED = 3;            // rad/s
    const FRICTION = 0.985;
    const SECTOR_RADIUS = 3000;     // mondo, esagono "virtuale"

    const ship = {
      x: 0,  // mondo
      y: 0,
      vx: 0,
      vy: 0,
      angle: -Math.PI/2 // verso l'alto
    };

    const keys = { up:false,down:false,left:false,right:false };

    window.addEventListener('keydown', e=>{
      if (e.code === 'ArrowUp') keys.up = true;
      if (e.code === 'ArrowDown') keys.down = true;
      if (e.code === 'ArrowLeft') keys.left = true;
      if (e.code === 'ArrowRight') keys.right = true;
    });
    window.addEventListener('keyup', e=>{
      if (e.code === 'ArrowUp') keys.up = false;
      if (e.code === 'ArrowDown') keys.down = false;
      if (e.code === 'ArrowLeft') keys.left = false;
      if (e.code === 'ArrowRight') keys.right = false;
    });

    // ---------- Stelle con parallax ----------
    let stars = [];
    function buildStars(){
      stars = [];
      const layers = [
        { density:0.30, parallax:0.20 },
        { density:0.20, parallax:0.45 },
        { density:0.10, parallax:0.85 }
      ];
      layers.forEach(layer=>{
        const count = Math.floor((W*H)/(9000/layer.density));
        for(let i=0;i<count;i++){
          stars.push({
            x: Math.random()*W,
            y: Math.random()*H,
            r: (Math.random()*1.2+0.4)*DPR,
            a: Math.random()*0.7+0.3,
            p: layer.parallax
          });
        }
      });
    }

    // ---------- Loop ----------
    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.05, (now-last)/1000);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    function update(dt){
      // rotazione
      if (keys.left)  ship.angle -= ANG_SPEED * dt;
      if (keys.right) ship.angle += ANG_SPEED * dt;

      const cos = Math.cos(ship.angle);
      const sin = Math.sin(ship.angle);

      // accel in avanti
      if (keys.up){
        ship.vx += cos * THRUST * dt;
        ship.vy += sin * THRUST * dt;
      }
      // freno lungo direzione di marcia
      if (keys.down){
        ship.vx -= cos * BRAKE * dt;
        ship.vy -= sin * BRAKE * dt;
      }

      // attrito
      ship.vx *= FRICTION;
      ship.vy *= FRICTION;

      // movimento nel mondo (settore)
      ship.x += ship.vx * dt;
      ship.y += ship.vy * dt;

      // clamp dentro settore (approssimato a cerchio)
      const dist = Math.hypot(ship.x, ship.y);
      const maxR = SECTOR_RADIUS - 50;
      if (dist > maxR){
        const scale = maxR / dist;
        ship.x *= scale;
        ship.y *= scale;
        ship.vx = 0;
        ship.vy = 0;
      }
    }

    function draw(){
      // sfondo
      gctx.fillStyle = '#020617';
      gctx.fillRect(0,0,W,H);

      // stelle in parallax
      for (const s of stars){
        let sx = s.x - ship.x * s.p * 0.03;
        let sy = s.y - ship.y * s.p * 0.03;

        // wrap schermo
        sx = ((sx % W) + W) % W;
        sy = ((sy % H) + H) % H;

        gctx.globalAlpha = s.a;
        gctx.beginPath();
        gctx.arc(sx, sy, s.r, 0, Math.PI*2);
        gctx.fillStyle = '#e5f1ff';
        gctx.fill();
      }
      gctx.globalAlpha = 1;

      // nave al centro schermo (camera lock)
      const cx = W/2;
      const cy = H/2;
      gctx.save();
      gctx.translate(cx, cy);
      gctx.rotate(ship.angle);
      // triangolo nave
      gctx.beginPath();
      gctx.moveTo(SHIP_SIZE*0.8, 0);
      gctx.lineTo(-SHIP_SIZE*0.6, SHIP_SIZE*0.4);
      gctx.lineTo(-SHIP_SIZE*0.6, -SHIP_SIZE*0.4);
      gctx.closePath();
      gctx.fillStyle = '#38bdf8';
      gctx.fill();
      gctx.lineWidth = 2*DPR;
      gctx.strokeStyle = '#0ea5e9';
      gctx.stroke();
      gctx.restore();

      drawMinimap();
    }

    // ---------- Minimap settore ----------
    function drawMinimap(){
      const w = minimap.width;
      const h = minimap.height;
      mctx.clearRect(0,0,w,h);

      const cx = w/2;
      const cy = h/2;
      const hexR = Math.min(w,h)*0.42;

      // esagono
      mctx.save();
      mctx.translate(cx, cy);
      mctx.beginPath();
      for(let i=0;i<6;i++){
        const ang = (Math.PI/3)*i + Math.PI/6;
        const x = Math.cos(ang)*hexR;
        const y = Math.sin(ang)*hexR;
        if (i===0) mctx.moveTo(x,y); else mctx.lineTo(x,y);
      }
      mctx.closePath();
      mctx.strokeStyle = '#4b5563';
      mctx.lineWidth = 2*DPR;
      mctx.stroke();

      // stella centrale (300px su 6000px => 5% del diametro)
      const starR = hexR * 0.05 * (6000/6000); // 5% del raggio
      mctx.beginPath();
      mctx.arc(0,0, starR, 0, Math.PI*2);
      mctx.fillStyle = '#ffffff';
      mctx.fill();

      // posizione nave
      const scale = hexR / SECTOR_RADIUS;
      const sx = ship.x * scale;
      const sy = ship.y * scale * -1; // inverti Y per leggibilità
      mctx.beginPath();
      mctx.arc(sx, sy, 3*DPR, 0, Math.PI*2);
      mctx.fillStyle = '#22c55e';
      mctx.fill();

      mctx.restore();
    }

  })();
  </script>
</body>
</html>
